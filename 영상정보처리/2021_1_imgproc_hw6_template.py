# -*- coding: utf-8 -*-
"""2021_1_ImgProc_HW6_Template.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nsjuU4eeKaYHMAF5w_6kf8ofp_Kg24gC

## 영상정보처리 6주차 과제 템플리트
- 마감: 4월 16일 오후 11:59
- 점수: 10점 만점
- 이미지 경로 잘못 사용한 경우: -3

이름: 황예진           
학번: 32195044
"""

from google.colab import drive 
drive.mount('/gdrive')

# Commented out IPython magic to ensure Python compatibility.
# %cd /gdrive/My Drive/Classroom/[영상정보처리] 2000004793-2021-1/2021-1 영상정보처리 6강/
import matplotlib.pyplot as plt
import numpy as np
import cv2

## print function
def show_with_matplotlib(img, title):
  """Shows an image using matplotlib capabilities"""

  #Convert BGR image to RGB:
  img_RGB = img[:,:,::-1]
  
  #Show the image using matplotlib:
  plt.imshow(img_RGB)
  plt.title(title)
  plt.show()

def show_with_matplotlib_gray(img, title):
  plt.imshow(img, cmap="gray")
  plt.title(title)
  plt.show()

"""다음의 경로는 변경하지 말것"""

image_path = '../Dongkeun-OpenCV-ImgData/lena.jpg'

"""##문제 1: 5점


1. 주어진 영상을 읽어 들인다 (org_img)
2. 입력 영상과 같은 크기의 빈 컬러 이미지를 만든다 (new_image)
3. 공백 이미지(new_image) 를 2 x 2 로 분할하여 4개의 서브이미지 영역을 구분한다.
4. 오른쪽 위를 1 영역이라고 하고, 시계 방향으로 2, 3, 4 영역이라고 한다. 
5. 1영역은 blue channel 값만을 가지고, 2영역은 green channel, 3영역은 red channel 값만 가지고, 4 영역은 3개의 channel 이 merging 된 영상을 집어 넣는다.
6. new_image 를 출력한다. 




"""

## 1번
org_img = cv2.imread(image_path, cv2.IMREAD_COLOR)
split_img = cv2.split(org_img)
## 2번
new_image = np.zeros(org_img.shape, dtype=np.uint8)

## 3번~5번

new_image[0:256, 256:512, 0] = split_img[0][0:256, 256:512]  #blue channel
new_image[256:512, 256:512, 1] = split_img[1][256:512, 256:512]  #green channel
new_image[256:512, 0:256, 2] = split_img[2][256:512, 0:256]  #red channel
new_image[0:256, 0:256] = cv2.merge([split_img[0][0:256, 0:256], split_img[1][0:256, 0:256], split_img[2][0:256, 0:256]])
#3 channel merging

## 6번
show_with_matplotlib(new_image, 'new image print')

"""### 문제 2: 5점
강의자료 2021-1 ImgProc JB-CH05-Updated2103-JH.pdf 에 있는 예제 중, 07.bitwise_op.py 와 08.bitwise_overlap.py 의 예제를 이 노트북에서 실행시키고, 각 라인을 분석해서 자기 노트를 만들기. 
- 예제에 사용하는 이미지가 '../Dongkeun-OpenCV-ImgData' 폴더에 없는 경우, 공유한 소스코드 폴더에서 필요한 이미지를 '../Dongkeun-OpenCV-ImgData' 에 복사해서 사용할 것. 

"""

## 07.bitwise_op.py
image1 = np.zeros((300, 300), np.uint8)     		# 300,300의 빈 영상 생성하기
image2 = image1.copy()  #image1과 똑같은 영상 생성하기

h, w = image1.shape[:2] #불러온 image1의 높이와 넓이 가져오기

cx,cy  = w//2, h//2 
#연산할 때 슬래쉬(/) 두 개는 정수값 가져오는 방법
#cx, cy에 중심값 저장

cv2.circle(image1, (cx,cy), 100, 255, -1)      		# 중심에 원 그리기
cv2.rectangle(image2, (0,0, cx, h), 255, -1)    # x중심을 기준으로 배경에 높이가 h인 사각형 그리기

image3 = cv2.bitwise_or(image1, image2)     	# 논리합 원과 사각형을 합치는 연산
image4 = cv2.bitwise_and(image1, image2)    	# 논리곱 원과 사각형이 겹치는 곳만 나타나는 연산
image5 = cv2.bitwise_xor(image1, image2)    	# 배타적 논리합 1과 0이 만나면 1로 나타나는 연산
image6 = cv2.bitwise_not(image1)            	# 행렬 반전 1과 1이 만나면 0으로 반전되는 연산

# 연산 결과값 모두 출력 
plt.imshow(cv2.cvtColor(image1, cv2.COLOR_BGR2RGB))
plt.title("image1")
plt.show()
plt.imshow(cv2.cvtColor(image2, cv2.COLOR_BGR2RGB))
plt.title("image2")
plt.show()
plt.imshow(cv2.cvtColor(image3, cv2.COLOR_BGR2RGB))
plt.title("bitwise_or")
plt.show()
plt.imshow(cv2.cvtColor(image4, cv2.COLOR_BGR2RGB))
plt.title("bitwise_and")
plt.show()
plt.imshow(cv2.cvtColor(image5, cv2.COLOR_BGR2RGB))
plt.title("bitwise_xor")
plt.show()
plt.imshow(cv2.cvtColor(image6, cv2.COLOR_BGR2RGB))
plt.title("bitwise_not")
plt.show()
cv2.waitKey(0)  #키 입력 대기

## 08.bitwise_overlab.py

image = cv2.imread("../Dongkeun-OpenCV-ImgData/images/bit_test.jpg", cv2.IMREAD_COLOR)     # 원본 컬러로 읽어오기
logo  = cv2.imread("../Dongkeun-OpenCV-ImgData/images/logo.jpg", cv2.IMREAD_COLOR)         # 로고 컬러로 읽어오기
if image is None or logo is None: raise Exception("영상 파일 읽기 오류 ")       # error 발생시 처리

masks = cv2.threshold(logo, 220, 255, cv2.THRESH_BINARY)[1]  # 영상 이진화 과정 (threshold 함수 사용)
  #블랙과 화이트만 존재하는 영상으로 만든다.(220보다 크면 화이트, 220보다 작으면 블랙, 최고값은 255로 제한)
  #인덱스 [1]이 붙는 이유는 bool형식으로 나오는 return value가 아닌 결과값을 얻어오기 위해서이다.
masks = cv2.split(masks)  #split를 거치면 채널 분리됨.

fg_pass_mask = cv2.bitwise_or(masks[0], masks[1])       # 전경 통과 마스크
  #blue 채널과 green 채널을 or 연산 (합치기)
fg_pass_mask = cv2.bitwise_or(masks[2], fg_pass_mask)
  #red 채널과 blue, green 채널을 or 연산 (합치기) 3 channel merging
bg_pass_mask = cv2.bitwise_not(fg_pass_mask)            # 배경 통과 마스크
  #3개의 채널을 merging한 영상을 not 연산

(H, W), (h, w) = image.shape[:2], logo.shape[:2]   #원래 image와 logo이미지의 높이, 넓이를 가져옴
x, y = (W-w)//2, (H - h)//2   #logo 시작 좌표를 가져오기
roi = image[y:y+h, x:x+w]   #시작 좌표를 기준으로 사용할 영역 지정

# 행렬 논리곱과 마스킹을 이용한 관심 영역 복사
foreground = cv2.bitwise_and(logo, logo, mask=fg_pass_mask) # 로고 부분 만들기
background = cv2.bitwise_and(roi , roi , mask=bg_pass_mask) # roi에 원본배경만 복사

dst = cv2.add(background, foreground)            # 두 이미지(로고 전경과 원본 배경) 합성
image[y:y+h, x:x+w] = dst             # 합성된 영상을 원본 이미지에 덮어 씌우기



show_with_matplotlib(background, "background")  #백그라운드 이미지 출력
show_with_matplotlib(foreground, "foreground") #포그라운드 이미지 출력
show_with_matplotlib(dst, "dst")  #합성된 이미지 출력
show_with_matplotlib(image, "image") #원본 image 출력
cv2.waitKey() #키 입력 대기