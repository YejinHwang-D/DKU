# -*- coding: utf-8 -*-
"""2021-1 ImgProc-HW13-Template.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15BjklxYthV6vyPy49U7kaqKLX0mJFbsm

## 영상정보처리 13주차 과제 템플리트

    
이름: 황예진            
학번: 32195044

입력 이미지: 자유

# 구글 드라이브 마우팅 및 작업 경로로 이동
- 다음 쉘에 필요한 작업을 하시오.
"""

from google.colab import drive
drive.mount('/gdrive')

# Commented out IPython magic to ensure Python compatibility.
# %cd /gdrive/My Drive/Classroom/[영상정보처리] 2000004793-2021-1/2021-1 영상정보처리 13강/
import matplotlib.pyplot as plt
import numpy as np
import cv2
from skimage.measure import compare_ssim

## print function
def show_with_matplotlib(img, title):
  """Shows an image using matplotlib capabilities"""

  #Convert BGR image to RGB:
  img_RGB = img[:,:,::-1]
  
  #Show the image using matplotlib:
  plt.imshow(img_RGB)
  plt.title(title)
  plt.show()

def show_with_matplotlib_gray(img, title):
  plt.imshow(img, cmap="gray")
  plt.title(title)
  plt.show()

def findEdgesBySobel(src_img):
  #1
  kx, ky = cv2.getDerivKernels(1, 0, ksize=3)
  sobelX = ky.dot(kx.T)
  gx = cv2.filter2D(src_img, cv2.CV_32F, sobelX)
  #2 
  kx, ky = cv2.getDerivKernels(0, 1, ksize=3)
  sobelY = ky.dit(kx.T)
  gy = cv2.filter2D(src_img, cv2.CV_32F, sobelY)
  #3
  mag = cv2.magnitude(gx, gy)
  ret, edge = cv2.threshold(mag, 100, 255, cv2.THRESH_BINARY)
  return edge

image_path = '../Dongkeun-OpenCV-ImgData/contour_test1.png'
src = cv2.imread(image_path)

"""##문제 1
수업 시간에 배운 다음의 방법들을 함수화 하고, 자유롭게 선택된 이미지를 이용하여 테스트 하시오.



1.   HoughLinesP 를 이용한 직선 성분 찾기
2.   contour 관련 함수들
  - 하나의 세그먼트에 대한 외곽선 그리기
  - 하나의 이미지에 있는 모든 세그먼트에 대한 외곽선 그리기 
  - 하나의 세그먼트에 대한 외곽선 그리기 영역 계산하기 
  - 하나의 컨투어에 대한 centroid 찾기
  - 하나의 컨투어에 대한 bounding rectangle 찾기
  - 하나의 컨투어에 대한 rotated rectangle 찾기
  - 하나의 컨투어에 대한 convex hull 찾기
  - 하나의 컨투어에 대한 convexity defects 찾기

# HoughLinesP를 이용한 직선 성분 찾기
"""

def hough_transform(low, high, thrsh): #패러미터 변경을 위한 함수
  image1 = src.copy()
  gray2 = cv2.cvtColor(src, cv2.COLOR_BGR2GRAY)
  edges = cv2.Canny(gray2, low, high)
  lines = cv2.HoughLinesP(edges, rho=1, theta=np.pi/180.0, threshold=thrsh)

  for line in lines:
   x1, y1, x2, y2 = line[0]
   cv2.line(image1, (x1,y1), (x2,y2), (0,0,255), 2)
  show_with_matplotlib(image1, "Image")

hough_transform(50, 100, 0) #Canny 범위 50~100 / threshold 값 100

"""# contour 관련 함수들

**1. 하나의 세그먼트에 대한 외곽선 그리기**
"""

gray = cv2.cvtColor(src, cv2.COLOR_BGR2GRAY)
ret, image = cv2.threshold(gray, 127, 255, 0)
mode = cv2.RETR_EXTERNAL
method = cv2.CHAIN_APPROX_SIMPLE

def draw_outline(num):
  image2 = src.copy()
  contours, hierarchy = cv2.findContours(image, mode, method)
  cv2.drawContours(image2, contours, num, (255,0,0), 3) #만약 0->-1이면 전체 세그먼트
  #for pt in contours[0][:]: #윤곽선 좌표
  #  cv2.circle(src, (pt[0][0], pt[0][1]), 5, (0,0,255), -1)
  show_with_matplotlib_gray(image2, "src with contours")
  
draw_outline(0)

"""**2. 하나의 이미지에 있는 모든 세그먼트에 대한 외곽선 그리기**"""

def draw_outline_all():
  image3 = src.copy()
  contours, hierarchy = cv2.findContours(gray, mode, method)
  cv2.drawContours(image3, contours, -1, (255,0,0), 3) #모든 세그먼트 윤곽선 그리기
  #for pt in contours[0][:]: #윤곽선 좌표
  #  cv2.circle(src, (pt[0][0], pt[0][1]), 5, (0,0,255), -1)
  show_with_matplotlib_gray(image3, "src with contours")
  
draw_outline_all()

"""**3. 하나의 세그먼트에 대한 외곽선 그리기 영역 계산하기**"""

#cv2.contourArea() 사용
def draw_outline_cal(num):
  
  cnt = contours[num]
  area = cv2.contourArea(cnt)
  print(area)
  
draw_outline_cal(0)

"""**4. 하나의 컨투어에 대한 centroid 찾기**"""

# 중심 찾기 => cv2.moments(cnt) / cx = int(M['m10']/M['m00']) / cy = int(M['m01']/M['m00'])
def find_centroid(num):
  image4 = src.copy()
  cnt = contours[num]
  M = cv2.moments(cnt)
  cx = int(M['m10']/M['m00'])
  cy = int(M['m01']/M['m00'])
  cv2.circle(image4, (cx, cy), 10, (0,0,255), -1)
  show_with_matplotlib(image4, "using cv2.moments()")
  
find_centroid(0)

"""**5. 하나의 컨투어에 대한 bounding rectangle 찾기**"""

#cv2.boundingRect()
def find_boundingRect(num):
  image5 = src.copy()
  cnt = contours[num]
  x, y, w, h = cv2.boundingRect(cnt)
  cv2.rectangle(image5, (x,y), (x+w, y+h), (0,255,0), 2)
  show_with_matplotlib(image5, "using cv2.boundingRect()")

find_boundingRect(0)

"""**6. 하나의 컨투어에 대한 rotated rectangle 찾기**"""

#회전된 직사각형 -> cv2.minAreaRect(cnt)
def find_rotatedRect(num):
  image6 = src.copy()
  cnt = contours[num]
  rect = cv2.minAreaRect(cnt)
  box = cv2.boxPoints(rect)
  box = np.int0(box)
  cv2.drawContours(image6, [box], 0, (0,0,255), 2)
  show_with_matplotlib(image6, "using cv2.minAreaRect()")

find_rotatedRect(0)

"""**7. 하나의 컨투어에 대한 convex hull 찾기**"""

# cv2.convexHull(cnt)
def find_convexHull(num):
  image7 = src.copy()
  cnt = contours[num]
  hull = cv2.convexHull(cnt)
  cv2.drawContours(image7, [hull], 0, (255,0,255), 5)
  show_with_matplotlib(image7, "using cv2.convexHull")

find_convexHull(0)

"""**8. 하나의 컨투어에 대한 convexity defects 찾기**"""

# cv2,ConvexityDefects(contour, convexhull, sotrage)
def find_convexityDefects():
  image8 = src.copy()
  icnt = 0
  for cnt in contours:
   hull = cv2.convexHull(cnt, returnPoints = False)
   defects = cv2.convexityDefects(cnt, hull)
   if icnt == 0:
     #print("cnt.shape =", cnt.shape, " cnt = ", cnt)
     print("hull.shape = ", hull.shape)
     thull = hull;
     print("max value in hull = ", max(thull.flatten()), "min value = ", min(thull.flatten()))
     print("hull = ", hull)
     print("defects[0].shape = ", defects[0].shape, "defects[0] = ", defects[0])
   icnt = icnt + 1

   for i in range(defects.shape[0]):
     s, e, f, d = defects[i, 0]
     start = tuple(cnt[s][0])
     end = tuple(cnt[e][0])
     far = tuple(cnt[f][0])

     print("distance =", d)
     if d > 300:
       cv2.line(image8, start, end, [0,255,0], 5)
       cv2.circle(image8, far, 5, [0,0,255], -1)
       title = "src with defects i = " + str(i)
       show_with_matplotlib(image8, title)

find_convexityDefects()